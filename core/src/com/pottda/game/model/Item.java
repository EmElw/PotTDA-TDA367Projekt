package com.pottda.game.model;

import javax.vecmath.Point2i;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;

/**
 * A basic Item, heavily modifiable based on properties
 */
public abstract class Item extends ProjectileListenerAdapter {

    public Item() {
        init();
    }

    /**
     * An AttackItem is a starting point and cannot be chained into
     */
    protected boolean isPrimaryAttack;
    /**
     * Secondary attacks have an attack function but are not
     * directly called from the Inventory to attack. Rather,
     * these are triggered attacks that handle their own
     * attacks on certain events
     */
    protected boolean isSecondaryAttack;
    /**
     * A ProjectileModifier modifies projectiles and needs to be attached as a ProjectileListener
     */
    protected boolean isProjectileModifier;
    /**
     * List of points relative to origin 0,0 of the item's positions
     */
    protected List<Point2i> basePositions;
    /**
     * List of points where the item will look for its output paths
     * (Generally only one)
     */
    protected List<Point2i> baseOutputs;
    /**
     * A List to the items output items, generated by the Inventory when it compiles
     */
    protected List<Item> outputItems;
    /**
     * The chance for an item to drop when the inventory containing it is destroyed
     * <p>
     * 1 = always dropped, 0 (default) = never dropped
     */
    protected float dropRate;

    protected String name;

    // -------------------------------------------------

    /**
     * Data structure containing values mapped to enums
     */
    protected Map<Stat, Double> statMap;
    /**
     * Direction of the item in terms of number pi/2 rotations
     */
    private int orientation;
    /**
     * X-orientation within its inventory
     */
    private int x;

    public int getOrientation() {
        return orientation;
    }

    public void setOrientation(int orientation) {
        this.orientation = orientation;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    /**
     * Y-orientation within its inventory
     */
    private int y;

    /**
     * Pseudo-constructor, called if instantiated without constructor (probably really bad practice)
     */
    public void init() {
        basePositions = new ArrayList<Point2i>();
        baseOutputs = new ArrayList<Point2i>();
        statMap = new EnumMap<Stat, Double>(Stat.class);
        outputItems = new ArrayList<Item>();
        // Set default properties
        isPrimaryAttack = false;
        isProjectileModifier = false;
        isSecondaryAttack = false;
        dropRate = 0;

        // Set properties based on dynamic type
        initDynamic();
    }

    /**
     * Returns a list of {@code Integer}, where each corresponds to a space where this item is.
     * <p>
     * The function sequences a coordinate grid with width {@code w} into a single number so
     * that i.e. (1,2) with w = 5 is equivalent to 1 + (2*5) = 11
     *
     * @param w the width of the grid
     * @return a {@code List<Integer>}
     */
    List<Integer> getPositionsAsIntegers(int w) {
        List<Integer> list = new ArrayList<Integer>();

        for (Point2i p : basePositions) {
            Point2i rotatedPoint = rotate(p.x, p.y, orientation);
            int v = (rotatedPoint.x + x) +    // Add x to convert to absolute coordinate in Inventory
                    (rotatedPoint.y + y) * w;     // Multiply to add the whole number of rows
            list.add(v);
        }

        return list;
    }

    /**
     * Returns a list of {@code Integer}, where each corresponds to a space where the item's
     * output is.
     * <p>
     * The function sequences a coordinate grid with width {@code w} into a single number so
     * that i.e. (1,2) with w = 5 is equivalent to 1 + (2*5) = 11
     *
     * @param w the width of the grid
     * @return a {@code List<Integer>}
     */
    List<Integer> getOutputAsInteger(int w) {
        List<Integer> list = new ArrayList<Integer>();

        for (Point2i p : baseOutputs) {
            Point2i rotatedPoint = rotate(p.x, p.y, orientation);
            int v = (rotatedPoint.x + x) +    // Add x to convert to absolute coordinate in Inventory
                    (rotatedPoint.y + y) * w;     // Multiply to add the whole number of rows
            list.add(v);
        }

        return list;
    }

    double getStat(Stat stat) {
        return statMap.containsKey(stat) ? statMap.get(stat) : 0;
    }

    /**
     * Is called at the end of init(), meaning it overrides the
     * default properties if wanted
     */
    protected abstract void initDynamic();

    /**
     * Basic iteration implementation, can be changed to
     * accomodate different behaviours such as toggling
     * outputs, no output, conditional outputs etc.
     *
     * @return an {@code Item}
     */
    protected Item getNext() {
        return outputItems.get(0);
    }

    public List<Point2i> getBasePositions() {
        return basePositions;
    }

    public List<Point2i> getBaseOutputs() {
        return baseOutputs;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return this.getClass().toString();
    }

    /**
     * Call to randomly determine if this item should be dropped
     *
     * @param rateMultiplier a factor that alters the dropRate
     * @return true if the item should be dropped
     */
    boolean drop(float rateMultiplier) {
        // TODO rateMultiplier is not used
        return Math.random() < dropRate;
    }

    /**
     * Returns a copy of a rotated 2D point by n * pi/2 rad or n * 90 degrees around (0,0)
     * <p>
     * Home-brew rotation function (because vecmath doesn't support 2D matrices?)
     *
     * @param x the x-coordinate of the point
     * @param y the y-coordinate of the point
     * @param n the rotation, expressed as n multiples of pi/2 rad
     * @return {@code int[]} of size 2
     */
    private static Point2i rotate(int x, int y, int n) {
        Point2i returnValue = new Point2i(x, y);
        returnValue.x = a[n] * x + b[n] * y;
        returnValue.y = c[n] * x + a[n] * y;
        return returnValue;
    }

    /**
     * Rotation matrix for r * pi/2
     * R = [ a[r] b[r] ; c[r] a[r]]
     */
    private static final int[] a = {1, 0, -1, 0};
    private static final int[] b = {0, -1, 0, 1};
    private static final int[] c = {0, 1, 0, -1};

    public List<Point2i> getTransformedRotatedOutputs() {

        List<Point2i> rotatedOutputs = new ArrayList<Point2i>();

        for (Point2i p : baseOutputs) {
            Point2i newPoint = rotate(p.x, p.y, orientation);
            newPoint.x += x;
            newPoint.y += y;
            rotatedOutputs.add(newPoint);
        }

        return rotatedOutputs;
    }

    /**
     * Returns a list of the item's positions as they are in the inventory
     *
     * @return
     */
    public List<? extends Point2i> getTransformedRotatedPositions() {

        List<Point2i> rotatedPositions = new ArrayList<Point2i>();

        for (Point2i p : baseOutputs) {
            Point2i newPoint = rotate(p.x, p.y, orientation);
            newPoint.x += x;
            newPoint.y += y;
            basePositions.add(newPoint);
        }

        return rotatedPositions;
    }

    private Point2i bottomLeft;

    public Point2i getBaseBottomLeft() {
        if (bottomLeft != null) {
            return new Point2i(bottomLeft);
        }
        int lx = 0, ly = 0;
        for (Point2i p : baseOutputs) {
            lx = Math.min(p.x, lx);
            ly = Math.min(p.y, ly);
        }
        for (Point2i p : basePositions) {
            lx = Math.min(p.x, lx);
            ly = Math.min(p.y, ly);
        }

        bottomLeft = new Point2i(lx, ly);

        return getBaseBottomLeft();
    }

    private Point2i upperRight;

    public Point2i getBaseUpperRight() {
        if (upperRight != null) {
            return new Point2i(upperRight);
        }
        int hx = 0, hy = 0;
        for (Point2i p : baseOutputs) {
            hx = Math.max(p.x, hx);
            hy = Math.max(p.y, hy);
        }
        for (Point2i p : basePositions) {
            hx = Math.max(p.x, hx);
            hy = Math.max(p.y, hy);
        }

        upperRight = new Point2i(hx, hy);

        return getBaseUpperRight();
    }
}
